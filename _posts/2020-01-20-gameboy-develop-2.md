---
layout: post
title:  "Gameboy游戏开发-精灵入门"
date:   2020-02-02 02:02:02
categories: gameboy game develop
---
上一节课我们展示了一个最简单的人物在屏幕内移动的例子，但人物移动时并没有配合的动画，这次我们来个高级版本的。在GB内我们管所有移动的物体都叫做精灵(Sprite)。组成精灵的瓦块(Tile)是一个8x8的像素组合。每个瓦块是一堆0或1位的组合，如果手工画这个肯定会疯掉。我们可以使用[Gameboy Tile Designer](http://www.devrs.com/gb/hmgd/gbtd.html)(以下简称gbtd)来进行瓦块的绘画。

### GBTD的使用

gbtd是个免费的绿色程序下载回来即可使用，macOS的用户可以通过wine来进行使用。运行GBTD后首先我们点击View选择Tile size,8x16。这里要做下解释GB的标准瓦块大小为8x8像素，但精灵特殊可以支持8x16的像素。GB的性能一个屏幕最多支持256个独立瓦块，GBC支持512个。大多游戏内一个主角都会使用掉16x16的像素来进行展示，也就是要同时控制4个瓦块，同屏幕精灵多了性能就会下降，所以我们要尽量使用8x16的精灵。
![gbtd](//blog.guohai.org/doc-pic/2020-02/gbtd.png)
这个截图是一个我已经做好的Mario的瓦块文件，前两个坐标的是mario静止时的状态，后几个下标是mario跑起来时的瓦块。我在附录里会把这个文件放出来，大家可以直接使用。接下来我们要导出gbdk可以用的.c文件。选择File->Export to->文件类型选择gbdk，filename我们使用mario.c，Label是我们数组变量的名字，我们也写上Mario。From会导出的瓦块下标，我们写入从0到9导出10个瓦块。
![gbtd](//blog.guohai.org/doc-pic/2020-02/gbtd-export.png)
导出后会生成一个mario.c的文件，我们打开看一下这就是我们后续要用到的瓦块。
~~~ c
unsigned char mario[] =
{
  0x07,0x07,0x0F,0x0F,0x01,0x0E,0x0B,0x14,
  0x09,0x16,0x07,0x18,0x07,0x00,0x02,0x0F,
  0x02,0x1F,0x03,0x3F,0x37,0x0D,0x3F,0x07,
  0x3F,0x0F,0x0E,0x0E,0x00,0x1C,0x00,0x3C,
  0xC0,0xC0,0xF8,0xF8,0xA0,0x40,0xB8,0x40,
  0xDC,0x20,0x80,0x78,0xF0,0x00,0x00,0xC0,
  0x40,0xF8,0xC0,0xFC,0xEC,0xB0,0xFC,0xE0,
  0xFC,0xF0,0x70,0x70,0x00,0x38,0x00,0x3C,
  0x07,0x07,0x0F,0x1F,0x00,0x3F,0x6D,0x12,
  0x6C,0x13,0x37,0x08,0x1C,0x1F,0x3E,0x31,
  0x2E,0x31,0x3E,0x39,0x1F,0x1F,0x11,0x1F,
  0x00,0x0F,0x0C,0x5F,0x02,0x7E,0x00,0x3C,
  0xC0,0xC0,0xF0,0xF0,0xA0,0x40,0xF8,0x00,
  0xCC,0x30,0xE0,0x18,0x70,0xC0,0xC0,0xF8,
  0x00,0xF8,0x00,0xF8,0x00,0xF0,0xE0,0xE0,
  0xE0,0xE0,0x40,0xC0,0x00,0x00,0x00,0x00,
  0x07,0x07,0x0F,0x0F,0x01,0x0E,0x0B,0x14,
  0x09,0x16,0x07,0x18,0x07,0x00,0x02,0x07,
  0x01,0x1F,0x03,0x1F,0x01,0x1F,0x13,0x1C,
  0x0B,0x0C,0x07,0x07,0x00,0x03,0x00,0x03,
  0xC0,0xC0,0xF8,0xF8,0xA0,0x40,0xB8,0x40,
  0xDC,0x20,0x80,0x78,0xF0,0x00,0x00,0xC0,
  0x80,0xE0,0xE0,0x60,0xF0,0xF0,0xF0,0x70,
  0xE0,0xE0,0x00,0xE0,0x00,0xF0,0x00,0x80,
  0x03,0x03,0x07,0x07,0x00,0x07,0x05,0x0A,
  0x04,0x0B,0x03,0x0C,0x03,0x00,0x00,0x07,
  0x08,0x07,0x1C,0x07,0x07,0x1F,0x0F,0x1F,
  0x0E,0x3E,0x00,0x21,0x00,0x01,0x00,0x00,
  0xE0,0xE0,0xFC,0xFC,0xD0,0x20,0xDC,0x20,
  0xEE,0x10,0xC0,0x3C,0xF8,0x00,0x48,0xE0,
  0x1C,0xE0,0x18,0xE0,0xF0,0xF0,0xF0,0xF0,
  0xE0,0xE0,0x00,0xC0,0x00,0xE0,0x00,0x00,
  0x07,0x07,0x0F,0x0F,0x01,0x0E,0x0B,0x14,
  0x09,0x16,0x07,0x18,0x07,0x00,0x03,0x3F,
  0xC3,0x3F,0xE2,0x0E,0xCF,0x0F,0x1F,0x1F,
  0x3F,0x3F,0x1C,0x7C,0x00,0x70,0x00,0x38,
  0xC0,0xC0,0xF8,0xF8,0xA0,0x40,0xB8,0x40,
  0xDC,0x20,0x80,0x78,0xF0,0x00,0x00,0xC0,
  0x8E,0xF0,0xE6,0xF8,0xE0,0xE4,0xF0,0xFC,
  0xF0,0xFC,0x70,0x7C,0x00,0x00,0x00,0x00
};
~~~

### 导入精灵到我们的程序中

### 机器介绍
要想做出GB下的游戏得先了解一下游戏机的基本性能。这里的GB只包含 第一代厚Gameboy,第二代超薄Gameboy Pocket,第三代最短暂的Gameboy Light,第四代Gameboy Color。再往后的GBA并不包含在内。CPU全系列均为z80cpu，只是不同的GB频率有区别。屏幕分辨率160x144像素，背景或窗体块大小8x8像素，对象/精灵块大小可以是8x8或8x16为了性能考虑建议使用8x16的块。大多游戏实际的角色都是16x16的像素块，当年的解决方案都是使用2个8x16拼接出来的，也就是每次角色的移动都要移动两组精灵。说到这里我们再来提下GB的层，GB一共有三个层分别是最下侧的背景层GB最多支持256个独立的块、GBC支持512个，再往上是精灵层也就是咱们一般放置在场景内移动的主角或敌人的层，如果使用8x8最多分别支持256/512个块。两个往上的是窗体层一般都是用来展示记分板，与背景层共用图像块。说完图像我们再来说颜色，最基本的GB是灰度的背景最多支持4级灰度，GBC支持4种颜色8种调色板，同一块上最多使用一种调色方案。
![gameboy layer](//blog.guohai.org/doc-pic/2020-01/gb_layer.png)


以上的讲解太抽象我们来看一个实例：

![Pokémon Gold Version](//blog.guohai.org/doc-pic/2020-01/pokemon_gold.png)

这是一个宝可梦金的截图，为了便于初期理解我去掉了调色板，左上角的框是屏幕内可以看到的范围，可以看到是由20x18个块(Tile)组成，其中每个块内有8x8个像素点。合起来也就是160x144个像素。那么每个视图内可以显示20x18也就是360个块已经超过了GB的256个限制是怎么解决的呢，答案是重复利用。仔细看画面里是大量重复的色块，组成色块的数组我们叫做map,map数组里标记的就是每一个色块的下标。
~~~ c
unsigned char rcmap[] =
{
  0x0D,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
  0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x0F,
  0x12,0x00,0x01,0x09,0x08,0x02,0x0B,0x01,0x02,0x0C,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x12,
  0x0E,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
  0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10
};
~~~
是的当年的8位机就是这么多的限制，好处就是游戏在画面上没法有太大的提升下各公司会理解注重游戏性和乐趣。以及不需要太复杂美术、建模几人的小团队也能做出很棒的游戏，可惜中国在2000年时放出了游戏禁令，错过了这个机会，即使今天在家用机上中国还可以说是空白。目前所有公司都希望在手游上可以实现弯道超车。